---
title: 'How debuggers work: Part 3 – Debugging information'
author: Johnson
type: post
date: 2016-08-05T08:04:48+00:00
categories:
  - C/C++
  - 编程语言
  - 软件调试
tags:
  - C/C++
  - Debug
  - Linux

---
<p align="right">
  <font color="#ff0000"><strong>Reproduce from</strong></font> <a title="http://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information" href="http://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information"><strong>http://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information</strong></a>
</p>

This is the third part in a series of articles on how debuggers work. Make sure you read [the first][1] and [the second][2] parts before this one.

##### In this part

I&#8217;m going to explain how the debugger figures out where to find the C functions and variables in the machine code it wades through, and the data it uses to map between C source code lines and machine language words.

##### Debugging information

Modern compilers do a pretty good job converting your high-level code, with its nicely indented and nested control structures and arbitrarily typed variables into a big pile of bits called machine code, the sole purpose of which is to run as fast as possible on the target CPU. Most lines of C get converted into several machine code instructions. Variables are shoved all over the place &#8211; into the stack, into registers, or completely optimized away. Structures and objects don&#8217;t even _exist_ in the resulting code &#8211; they&#8217;re merely an abstraction that gets translated to hard-coded offsets into memory buffers.

So how does a debugger know where to stop when you ask it to break at the entry to some function? How does it manage to find what to show you when you ask it for the value of a variable? The answer is &#8211; debugging information.

<div align="right">
  <!--more-->
</div>

Debugging information is generated by the compiler together with the machine code. It is a representation of the relationship between the executable program and the original source code. This information is encoded into a pre-defined format and stored alongside the machine code. Many such formats were invented over the years for different platforms and executable files. Since the aim of this article isn&#8217;t to survey the history of these formats, but rather to show how they work, we&#8217;ll have to settle on something. This something is going to be DWARF, which is almost ubiquitously used today as the debugging information format for ELF executables on Linux and other Unix-y platforms.

##### The DWARF in the ELF

<img style="float: none; margin-left: auto; display: block; margin-right: auto" src="http://eli.thegreenplace.net/images/2011/02/dwarf_logo.gif" />

According to [its Wikipedia page][3], DWARF was designed alongside ELF, although it can in theory be embedded in other object file formats as well [[1]][4].

DWARF is a complex format, building on many years of experience with previous formats for various architectures and operating systems. It has to be complex, since it solves a very tricky problem &#8211; presenting debugging information from any high-level language to debuggers, providing support for arbitrary platforms and ABIs. It would take much more than this humble article to explain it fully, and to be honest I don&#8217;t understand all its dark corners well enough to engage in such an endeavor anyway [[2]][5]. In this article I will take a more hands-on approach, showing just enough of DWARF to explain how debugging information works in practical terms.

##### Debug sections in ELF files

First let&#8217;s take a glimpse of where the DWARF info is placed inside ELF files. ELF defines arbitrary sections that may exist in each object file. A _section header table_ defines which sections exist and their names. Different tools treat various sections in special ways &#8211; for example the linker is looking for some sections, the debugger for others.

We&#8217;ll be using an executable built from this C source for our experiments in this article, compiled into <tt>tracedprog2</tt>:

> #include <stdio.h>
> 
> void do\_stuff(int my\_arg)   
> {   
> &#160;&#160;&#160; int my\_local = my\_arg + 2;   
> &#160;&#160;&#160; int i;
> 
> &#160;&#160;&#160; for (i = 0; i < my_local; ++i)   
> &#160;&#160;&#160;&#160;&#160;&#160;&#160; printf("i = %d\n", i);   
> }
> 
> int main()   
> {   
> &#160;&#160;&#160; do_stuff(2);   
> &#160;&#160;&#160; return 0;   
> }

Dumping the section headers from the ELF executable using <tt>objdump -h</tt> we&#8217;ll notice several sections with names beginning with <tt>.debug_</tt> &#8211; these are the DWARF debugging sections:

> 26 .debug_aranges 00000020&#160; 00000000&#160; 00000000&#160; 00001037   
> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; CONTENTS, READONLY, DEBUGGING   
> 27 .debug_pubnames 00000028&#160; 00000000&#160; 00000000&#160; 00001057   
> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; CONTENTS, READONLY, DEBUGGING   
> 28 .debug_info&#160;&#160; 000000cc&#160; 00000000&#160; 00000000&#160; 0000107f   
> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; CONTENTS, READONLY, DEBUGGING   
> 29 .debug_abbrev 0000008a&#160; 00000000&#160; 00000000&#160; 0000114b   
> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; CONTENTS, READONLY, DEBUGGING   
> 30 .debug_line&#160;&#160; 0000006b&#160; 00000000&#160; 00000000&#160; 000011d5   
> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; CONTENTS, READONLY, DEBUGGING   
> 31 .debug_frame&#160; 00000044&#160; 00000000&#160; 00000000&#160; 00001240   
> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; CONTENTS, READONLY, DEBUGGING   
> 32 .debug_str&#160;&#160;&#160; 000000ae&#160; 00000000&#160; 00000000&#160; 00001284   
> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; CONTENTS, READONLY, DEBUGGING   
> 33 .debug_loc&#160;&#160;&#160; 00000058&#160; 00000000&#160; 00000000&#160; 00001332   
> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; CONTENTS, READONLY, DEBUGGING

The first number seen for each section here is its size, and the last is the offset where it begins in the ELF file. The debugger uses this information to read the section from the executable.

Now let&#8217;s see a few practical examples of finding useful debug information in DWARF.

##### Finding functions

One of the most basic things we want to do when debugging is placing breakpoints at some function, expecting the debugger to break right at its entrance. To be able to perform this feat, the debugger must have some mapping between a function name in the high-level code and the address in the machine code where the instructions for this function begin.

This information can be obtained from DWARF by looking at the <tt>.debug_info</tt> section. Before we go further, a bit of background. The basic descriptive entity in DWARF is called the Debugging Information Entry (DIE). Each DIE has a tag &#8211; its type, and a set of attributes. DIEs are interlinked via sibling and child links, and values of attributes can point at other DIEs.

Let&#8217;s run:

> objdump &#8211;dwarf=info tracedprog2

The output is quite long, and for this example we&#8217;ll just focus on these lines [[3]][6]:

> <1><71>: Abbrev Number: 5 (DW\_TAG\_subprogram)   
> &#160;&#160;&#160; <72>&#160;&#160; DW\_AT\_external&#160;&#160;&#160; : 1   
> &#160;&#160;&#160; <73>&#160;&#160; DW\_AT\_name&#160;&#160;&#160;&#160;&#160;&#160;&#160; : (&#8230;): do_stuff   
> &#160;&#160;&#160; <77>&#160;&#160; DW\_AT\_decl_file&#160;&#160; : 1   
> &#160;&#160;&#160; <78>&#160;&#160; DW\_AT\_decl_line&#160;&#160; : 4   
> &#160;&#160;&#160; <79>&#160;&#160; DW\_AT\_prototyped&#160; : 1   
> &#160;&#160;&#160; <7a>&#160;&#160; DW\_AT\_low_pc&#160;&#160;&#160;&#160;&#160; : 0x8048604   
> &#160;&#160;&#160; <7e>&#160;&#160; DW\_AT\_high_pc&#160;&#160;&#160;&#160; : 0x804863e   
> &#160;&#160;&#160; <82>&#160;&#160; DW\_AT\_frame_base&#160; : 0x0&#160;&#160;&#160;&#160;&#160; (location list)   
> &#160;&#160;&#160; <86>&#160;&#160; DW\_AT\_sibling&#160;&#160;&#160;&#160; : <0xb3>
> 
> <1><b3>: Abbrev Number: 9 (DW\_TAG\_subprogram)   
> &#160;&#160;&#160; <b4>&#160;&#160; DW\_AT\_external&#160;&#160;&#160; : 1   
> &#160;&#160;&#160; <b5>&#160;&#160; DW\_AT\_name&#160;&#160;&#160;&#160;&#160;&#160;&#160; : (&#8230;): main   
> &#160;&#160;&#160; <b9>&#160;&#160; DW\_AT\_decl_file&#160;&#160; : 1   
> &#160;&#160;&#160; <ba>&#160;&#160; DW\_AT\_decl_line&#160;&#160; : 14   
> &#160;&#160;&#160; <bb>&#160;&#160; DW\_AT\_type&#160;&#160;&#160;&#160;&#160;&#160;&#160; : <0x4b>   
> &#160;&#160;&#160; <bf>&#160;&#160; DW\_AT\_low_pc&#160;&#160;&#160;&#160;&#160; : 0x804863e   
> &#160;&#160;&#160; <c3>&#160;&#160; DW\_AT\_high_pc&#160;&#160;&#160;&#160; : 0x804865a   
> &#160;&#160;&#160; <c7>&#160;&#160; DW\_AT\_frame_base&#160; : 0x2c&#160;&#160;&#160;&#160; (location list)

There are two entries (DIEs) tagged <tt>DW_TAG_subprogram</tt>, which is a function in DWARF&#8217;s jargon. Note that there&#8217;s an entry for <tt>do_stuff</tt> and an entry for <tt>main</tt>. There are several interesting attributes, but the one that interests us here is <tt>DW_AT_low_pc</tt>. This is the program-counter (<tt>EIP</tt> in x86) value for the beginning of the function. Note that it&#8217;s <tt>0x8048604</tt> for <tt>do_stuff</tt>. Now let&#8217;s see what this address is in the disassembly of the executable by running <tt>objdump -d</tt>:

> 08048604 <do_stuff>:   
> 8048604:&#160;&#160;&#160;&#160;&#160;&#160; 55&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; push&#160;&#160; ebp   
> 8048605:&#160;&#160;&#160;&#160;&#160;&#160; 89 e5&#160;&#160;&#160;&#160;&#160;&#160;&#160; mov&#160;&#160;&#160; ebp,esp   
> 8048607:&#160;&#160;&#160;&#160;&#160;&#160; 83 ec 28&#160;&#160;&#160;&#160; sub&#160;&#160;&#160; esp,0x28   
> 804860a:&#160;&#160;&#160;&#160;&#160;&#160; 8b 45 08&#160;&#160;&#160;&#160; mov&#160;&#160;&#160; eax,DWORD PTR [ebp+0x8]   
> 804860d:&#160;&#160;&#160;&#160;&#160;&#160; 83 c0 02&#160;&#160;&#160;&#160; add&#160;&#160;&#160; eax,0x2   
> 8048610:&#160;&#160;&#160;&#160;&#160;&#160; 89 45 f4&#160;&#160;&#160;&#160; mov&#160;&#160;&#160; DWORD PTR [ebp-0xc],eax   
> 8048613:&#160;&#160;&#160;&#160;&#160;&#160; c7 45 (&#8230;)&#160; mov&#160;&#160;&#160; DWORD PTR [ebp-0x10],0x0   
> 804861a:&#160;&#160;&#160;&#160;&#160;&#160; eb 18&#160;&#160;&#160;&#160;&#160;&#160;&#160; jmp&#160;&#160;&#160; 8048634 <do_stuff+0x30>   
> 804861c:&#160;&#160;&#160;&#160;&#160;&#160; b8 20 (&#8230;)&#160; mov&#160;&#160;&#160; eax,0x8048720   
> 8048621:&#160;&#160;&#160;&#160;&#160;&#160; 8b 55 f0&#160;&#160;&#160;&#160; mov&#160;&#160;&#160; edx,DWORD PTR [ebp-0x10]   
> 8048624:&#160;&#160;&#160;&#160;&#160;&#160; 89 54 24 04&#160; mov&#160;&#160;&#160; DWORD PTR [esp+0x4],edx   
> 8048628:&#160;&#160;&#160;&#160;&#160;&#160; 89 04 24&#160;&#160;&#160;&#160; mov&#160;&#160;&#160; DWORD PTR [esp],eax   
> 804862b:&#160;&#160;&#160;&#160;&#160;&#160; e8 04 (&#8230;)&#160; call&#160;&#160; 8048534 <printf@plt>   
> 8048630:&#160;&#160;&#160;&#160;&#160;&#160; 83 45 f0 01&#160; add&#160;&#160;&#160; DWORD PTR [ebp-0x10],0x1   
> 8048634:&#160;&#160;&#160;&#160;&#160;&#160; 8b 45 f0&#160;&#160;&#160;&#160; mov&#160;&#160;&#160; eax,DWORD PTR [ebp-0x10]   
> 8048637:&#160;&#160;&#160;&#160;&#160;&#160; 3b 45 f4&#160;&#160;&#160;&#160; cmp&#160;&#160;&#160; eax,DWORD PTR [ebp-0xc]   
> 804863a:&#160;&#160;&#160;&#160;&#160;&#160; 7c e0&#160;&#160;&#160;&#160;&#160;&#160;&#160; jl&#160;&#160;&#160;&#160; 804861c <do_stuff+0x18>   
> 804863c:&#160;&#160;&#160;&#160;&#160;&#160; c9&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; leave   
> 804863d:&#160;&#160;&#160;&#160;&#160;&#160; c3&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ret

Indeed, <tt>0x8048604</tt> is the beginning of <tt>do_stuff</tt>, so the debugger can have a mapping between functions and their locations in the executable.

##### Finding variables

Suppose that we&#8217;ve indeed stopped at a breakpoint inside <tt>do_stuff</tt>. We want to ask the debugger to show us the value of the <tt>my_local</tt> variable. How does it know where to find it? Turns out this is much trickier than finding functions. Variables can be located in global storage, on the stack, and even in registers. Additionally, variables with the same name can have different values in different lexical scopes. The debugging information has to be able to reflect all these variations, and indeed DWARF does.

I won&#8217;t cover all the possibilities, but as an example I&#8217;ll demonstrate how the debugger can find<tt>my_local</tt> in <tt>do_stuff</tt>. Let&#8217;s start at <tt>.debug_info</tt> and look at the entry for <tt>do_stuff</tt> again, this time also looking at a couple of its sub-entries:

> <1><71>: Abbrev Number: 5 (DW\_TAG\_subprogram)   
> &#160;&#160;&#160; <72>&#160;&#160; DW\_AT\_external&#160;&#160;&#160; : 1   
> &#160;&#160;&#160; <73>&#160;&#160; DW\_AT\_name&#160;&#160;&#160;&#160;&#160;&#160;&#160; : (&#8230;): do_stuff   
> &#160;&#160;&#160; <77>&#160;&#160; DW\_AT\_decl_file&#160;&#160; : 1   
> &#160;&#160;&#160; <78>&#160;&#160; DW\_AT\_decl_line&#160;&#160; : 4   
> &#160;&#160;&#160; <79>&#160;&#160; DW\_AT\_prototyped&#160; : 1   
> &#160;&#160;&#160; <7a>&#160;&#160; DW\_AT\_low_pc&#160;&#160;&#160;&#160;&#160; : 0x8048604   
> &#160;&#160;&#160; <7e>&#160;&#160; DW\_AT\_high_pc&#160;&#160;&#160;&#160; : 0x804863e   
> &#160;&#160;&#160; <82>&#160;&#160; DW\_AT\_frame_base&#160; : 0x0&#160;&#160;&#160;&#160;&#160; (location list)   
> &#160;&#160;&#160; <86>&#160;&#160; DW\_AT\_sibling&#160;&#160;&#160;&#160; : <0xb3>   
> <2><8a>: Abbrev Number: 6 (DW\_TAG\_formal_parameter)   
> &#160;&#160;&#160; <8b>&#160;&#160; DW\_AT\_name&#160;&#160;&#160;&#160;&#160;&#160;&#160; : (&#8230;): my_arg   
> &#160;&#160;&#160; <8f>&#160;&#160; DW\_AT\_decl_file&#160;&#160; : 1   
> &#160;&#160;&#160; <90>&#160;&#160; DW\_AT\_decl_line&#160;&#160; : 4   
> &#160;&#160;&#160; <91>&#160;&#160; DW\_AT\_type&#160;&#160;&#160;&#160;&#160;&#160;&#160; : <0x4b>   
> &#160;&#160;&#160; <95>&#160;&#160; DW\_AT\_location&#160;&#160;&#160; : (&#8230;)&#160;&#160;&#160;&#160;&#160;&#160; (DW\_OP\_fbreg: 0)   
> <2><98>: Abbrev Number: 7 (DW\_TAG\_variable)   
> &#160;&#160;&#160; <99>&#160;&#160; DW\_AT\_name&#160;&#160;&#160;&#160;&#160;&#160;&#160; : (&#8230;): my_local   
> &#160;&#160;&#160; <9d>&#160;&#160; DW\_AT\_decl_file&#160;&#160; : 1   
> &#160;&#160;&#160; <9e>&#160;&#160; DW\_AT\_decl_line&#160;&#160; : 6   
> &#160;&#160;&#160; <9f>&#160;&#160; DW\_AT\_type&#160;&#160;&#160;&#160;&#160;&#160;&#160; : <0x4b>   
> &#160;&#160;&#160; <a3>&#160;&#160; DW\_AT\_location&#160;&#160;&#160; : (&#8230;)&#160;&#160;&#160;&#160;&#160; (DW\_OP\_fbreg: -20)   
> <2><a6>: Abbrev Number: 8 (DW\_TAG\_variable)   
> &#160;&#160;&#160; <a7>&#160;&#160; DW\_AT\_name&#160;&#160;&#160;&#160;&#160;&#160;&#160; : i   
> &#160;&#160;&#160; <a9>&#160;&#160; DW\_AT\_decl_file&#160;&#160; : 1   
> &#160;&#160;&#160; <aa>&#160;&#160; DW\_AT\_decl_line&#160;&#160; : 7   
> &#160;&#160;&#160; <ab>&#160;&#160; DW\_AT\_type&#160;&#160;&#160;&#160;&#160;&#160;&#160; : <0x4b>   
> &#160;&#160;&#160; <af>&#160;&#160; DW\_AT\_location&#160;&#160;&#160; : (&#8230;)&#160;&#160;&#160;&#160;&#160; (DW\_OP\_fbreg: -24)

Note the first number inside the angle brackets in each entry. This is the nesting level &#8211; in this example entries with <tt><2></tt> are children of the entry with <tt><1></tt>. So we know that the variable <tt>my_local</tt> (marked by the <tt>DW_TAG_variable</tt> tag) is a child of the <tt>do_stuff</tt> function. The debugger is also interested in a variable&#8217;s type to be able to display it correctly. In the case of <tt>my_local</tt> the type points to another DIE &#8211; <tt><0x4b></tt>. If we look it up in the output of <tt>objdump</tt> we&#8217;ll see it&#8217;s a signed 4-byte integer.

To actually locate the variable in the memory image of the executing process, the debugger will look at the <tt>DW_AT_location</tt> attribute. For <tt>my_local</tt> it says <tt>DW_OP_fbreg: -20</tt>. This means that the variable is stored at offset -20 from the <tt>DW_AT_frame_base</tt> attribute of its containing function &#8211; which is the base of the frame for the function.

The <tt>DW_AT_frame_base</tt> attribute of <tt>do_stuff</tt> has the value <tt>0x0 (location list)</tt>, which means that this value actually has to be looked up in the location list section. Let&#8217;s look at it:

> $ objdump &#8211;dwarf=loc tracedprog2
> 
> tracedprog2:&#160;&#160;&#160;&#160; file format elf32-i386
> 
> Contents of the .debug_loc section:
> 
> &#160;&#160;&#160; Offset&#160;&#160; Begin&#160;&#160;&#160; End&#160;&#160;&#160;&#160;&#160; Expression   
> &#160;&#160;&#160; 00000000 08048604 08048605 (DW\_OP\_breg4: 4 )   
> &#160;&#160;&#160; 00000000 08048605 08048607 (DW\_OP\_breg4: 8 )   
> &#160;&#160;&#160; 00000000 08048607 0804863e (DW\_OP\_breg5: 8 )   
> &#160;&#160;&#160; 00000000 <End of list>   
> &#160;&#160;&#160; 0000002c 0804863e 0804863f (DW\_OP\_breg4: 4 )   
> &#160;&#160;&#160; 0000002c 0804863f 08048641 (DW\_OP\_breg4: 8 )   
> &#160;&#160;&#160; 0000002c 08048641 0804865a (DW\_OP\_breg5: 8 )   
> &#160;&#160;&#160; 0000002c <End of list>

The location information we&#8217;re interested in is the first one [[4]][7]. For each address where the debugger may be, it specifies the current frame base from which offsets to variables are to be computed as an offset from a register. For x86, <tt>bpreg4</tt> refers to <tt>esp</tt> and <tt>bpreg5</tt> refers to <tt>ebp</tt>.

It&#8217;s educational to look at the first several instructions of <tt>do_stuff</tt> again:

> 08048604 <do_stuff>:   
> 8048604:&#160;&#160;&#160;&#160;&#160;&#160; 55&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; push&#160;&#160; ebp   
> 8048605:&#160;&#160;&#160;&#160;&#160;&#160; 89 e5&#160;&#160;&#160;&#160;&#160;&#160; mov&#160;&#160;&#160; ebp,esp   
> 8048607:&#160;&#160;&#160;&#160;&#160;&#160; 83 ec 28&#160;&#160;&#160; sub&#160;&#160;&#160; esp,0x28   
> 804860a:&#160;&#160;&#160;&#160;&#160;&#160; 8b 45 08&#160;&#160;&#160; mov&#160;&#160;&#160; eax,DWORD PTR [ebp+0x8]   
> 804860d:&#160;&#160;&#160;&#160;&#160;&#160; 83 c0 02&#160;&#160;&#160; add&#160;&#160;&#160; eax,0x2   
> 8048610:&#160;&#160;&#160;&#160;&#160;&#160; 89 45 f4&#160;&#160;&#160; mov&#160;&#160;&#160; DWORD PTR [ebp-0xc],eax

Note that <tt>ebp</tt> becomes relevant only after the second instruction is executed, and indeed for the first two addresses the base is computed from <tt>esp</tt> in the location information listed above. Once <tt>ebp</tt> is valid, it&#8217;s convenient to compute offsets relative to it because it stays constant while <tt>esp</tt> keeps moving with data being pushed and popped from the stack.

So where does it leave us with <tt>my_local</tt>? We&#8217;re only really interested in its value after the instruction at <tt>0x8048610</tt> (where its value is placed in memory after being computed in <tt>eax</tt>), so the debugger will be using the <tt>DW_OP_breg5: 8</tt> frame base to find it. Now it&#8217;s time to rewind a little and recall that the<tt>DW_AT_location</tt> attribute for <tt>my_local</tt> says <tt>DW_OP_fbreg: -20</tt>. Let&#8217;s do the math: -20 from the frame base, which is <tt>ebp + 8</tt>. We get <tt>ebp - 12</tt>. Now look at the disassembly again and note where the data is moved from <tt>eax</tt> &#8211; indeed, <tt>ebp - 12</tt> is where <tt>my_local</tt> is stored.

##### Looking up line numbers

When we talked about finding functions in the debugging information, I was cheating a little. When we debug C source code and put a breakpoint in a function, we&#8217;re usually not interested in the first _machine code_ instruction [[5]][8]. What we&#8217;re _really_ interested in is the first _C code_ line of the function.

This is why DWARF encodes a full mapping between lines in the C source code and machine code addresses in the executable. This information is contained in the <tt>.debug_line</tt> section and can be extracted in a readable form as follows:

> $ objdump &#8211;dwarf=decodedline tracedprog2
> 
> tracedprog2:&#160;&#160;&#160;&#160; file format elf32-i386
> 
> Decoded dump of debug contents of section .debug_line:
> 
> CU: /home/eliben/eli/eliben-code/debugger/tracedprog2.c:   
> File name&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Line number&#160;&#160;&#160; Starting address   
> tracedprog2.c&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 5&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 0x8048604   
> tracedprog2.c&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 6&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 0x804860a   
> tracedprog2.c&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 9&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 0x8048613   
> tracedprog2.c&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 10&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 0x804861c   
> tracedprog2.c&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 9&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 0x8048630   
> tracedprog2.c&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 11&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 0x804863c   
> tracedprog2.c&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 15&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 0x804863e   
> tracedprog2.c&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 16&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 0x8048647   
> tracedprog2.c&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 17&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 0x8048653   
> tracedprog2.c&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 18&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 0x8048658

It shouldn&#8217;t be hard to see the correspondence between this information, the C source code and the disassembly dump. Line number 5 points at the entry point to <tt>do_stuff</tt> &#8211; <tt>0x8040604</tt>. The next line, 6, is where the debugger should really stop when asked to break in <tt>do_stuff</tt>, and it points at <tt>0x804860a</tt> which is just past the prologue of the function. This line information easily allows bi-directional mapping between lines and addresses:

  * When asked to place a breakpoint at a certain line, the debugger will use it to find which address it should put its trap on (remember our friend <tt>int 3</tt> from the previous article?) 
  * When an instruction causes a segmentation fault, the debugger will use it to find the source code line on which it happened. 

##### <tt>libdwarf</tt> &#8211; Working with DWARF programmatically

Employing command-line tools to access DWARF information, while useful, isn&#8217;t fully satisfying. As programmers, we&#8217;d like to know how to write actual code that can read the format and extract what we need from it.

Naturally, one approach is to grab the DWARF specification and start hacking away. Now, remember how everyone keeps saying that you should never, ever parse HTML manually but rather use a library? Well, with DWARF it&#8217;s even worse. DWARF is _much_ more complex than HTML. What I&#8217;ve shown here is just the tip of the iceberg, and to make things even harder, most of this information is encoded in a very compact and compressed way in the actual object file [[6]][9].

So we&#8217;ll take another road and use a library to work with DWARF. There are two major libraries I&#8217;m aware of (plus a few less complete ones):

  1. BFD (<tt>libbfd</tt>) is used by the [GNU binutils][10], including <tt>objdump</tt> which played a star role in this article, <tt>ld</tt> (the GNU linker) and <tt>as</tt> (the GNU assembler). 
  2. <tt>libdwarf</tt> &#8211; which together with its big brother <tt>libelf</tt> are used for the tools on Solaris and FreeBSD operating systems. 

I&#8217;m picking <tt>libdwarf</tt> over BFD because it appears less arcane to me and its license is more liberal (<tt>LGPL</tt>vs. <tt>GPL</tt>).

Since <tt>libdwarf</tt> is itself quite complex it requires a lot of code to operate. I&#8217;m not going to show all this code here, but [you can download][11] and run it yourself. To compile this file you&#8217;ll need to have <tt>libelf</tt>and <tt>libdwarf</tt> installed, and pass the <tt>-lelf</tt> and <tt>-ldwarf</tt> flags to the linker.

The demonstrated program takes an executable and prints the names of functions in it, along with their entry points. Here&#8217;s what it produces for the C program we&#8217;ve been playing with in this article:

> $ dwarf\_get\_func_addr tracedprog2   
> DW\_TAG\_subprogram: &#8216;do_stuff&#8217;   
> low pc&#160; : 0x08048604   
> high pc : 0x0804863e   
> DW\_TAG\_subprogram: &#8216;main&#8217;   
> low pc&#160; : 0x0804863e   
> high pc : 0x0804865a

The documentation of <tt>libdwarf</tt> (linked in the References section of this article) is quite good, and with some effort you should have no problem pulling any other information demonstrated in this article from the DWARF sections using it.

##### Conclusion and next steps

Debugging information is a simple concept in principle. The implementation details may be intricate, but in the end of the day what matters is that we now know how the debugger finds the information it needs about the original source code from which the executable it&#8217;s tracing was compiled. With this information in hand, the debugger bridges between the world of the user, who thinks in terms of lines of code and data structures, and the world of the executable, which is just a bunch of machine code instructions and data in registers and memory.

This article, with its two predecessors, concludes an introductory series that explains the inner workings of a debugger. Using the information presented here and some programming effort, it should be possible to create a basic but functional debugger for Linux.

As for the next steps, I&#8217;m not sure yet. Maybe I&#8217;ll end the series here, maybe I&#8217;ll present some advanced topics such as backtraces, and perhaps debugging on Windows. Readers can also suggest ideas for future articles in this series or related material. Feel free to use the comments or send me an email.

##### References

  * <tt>objdump</tt> man page 
  * Wikipedia pages for [ELF][12] and [DWARF][3]. 
  * [Dwarf Debugging Standard home page][13] &#8211; from here you can obtain the excellent DWARF tutorial by Michael Eager, as well as the DWARF standard itself. You&#8217;ll probably want version 2 since it&#8217;s what <tt>gcc</tt>produces. 
  * [libdwarf home page][14] &#8211; the download package includes a comprehensive reference document for the library 
  * [BFD documentation][15]&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;  ![][16]</ul> 

[[1]][17]DWARF is an open standard, published [here][13] by the DWARF standards committee. The DWARF logo displayed above is taken from that website.

[[2]][18]At the end of the article I&#8217;ve collected some useful resources that will help you get more familiar with DWARF, if you&#8217;re interested. Particularly, start with the DWARF tutorial.

[[3]][19]Here and in subsequent examples, I&#8217;m placing <tt>(...)</tt> instead of some longer and un-interesting information for the sake of more convenient formatting.

[[4]][20]Because the <tt>DW_AT_frame_base</tt> attribute of <tt>do_stuff</tt> contains offset <tt>0x0</tt> into the location list. Note that the same attribute for <tt>main</tt> contains the offset <tt>0x2c</tt> which is the offset for the second set of location expressions.

[[5]][21]Where the function prologue is usually executed and the local variables aren&#8217;t even valid yet.

[[6]][22]Some parts of the information (such as location data and line number data) are encoded as instructions for a specialized virtual machine. Yes, really.

 [1]: http://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1/
 [2]: http://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints/
 [3]: http://en.wikipedia.org/wiki/DWARF
 [4]: http://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information#id7
 [5]: http://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information#id8
 [6]: http://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information#id9
 [7]: http://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information#id10
 [8]: http://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information#id11
 [9]: http://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information#id12
 [10]: http://www.gnu.org/software/binutils/
 [11]: https://github.com/eliben/code-for-blog/blob/master/2011/dwarf_get_func_addr.c
 [12]: http://en.wikipedia.org/wiki/Executable_and_Linkable_Format
 [13]: http://dwarfstd.org/
 [14]: http://reality.sgiweb.org/davea/dwarf.html
 [15]: http://sourceware.org/binutils/docs-2.21/bfd/index.html
 [16]: http://eli.thegreenplace.net/images/hline.jpg
 [17]: http://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information#id1
 [18]: http://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information#id2
 [19]: http://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information#id3
 [20]: http://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information#id4
 [21]: http://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information#id5
 [22]: http://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information#id6